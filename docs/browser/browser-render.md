# 浏览器的渲染

渲染进程（Renderer process）几乎负责浏览器 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。渲染进程中主要包含以下线程：

- Main thread 一个主线程
- Worker thread 多个工作线程
- Compositor thread 一个合成器线程
- Raster thread 多个光栅化线程

## 渲染流程

### 1、构建 DOM

当渲染进程接收到浏览器进程发起的“提交文档”消息，开始接收 HTML 数据时，主线程会解析文本字符串为 DOM。

渲染 HTML 为 DOM 的方法由 [HTML Standard](https://whatwg-cn.github.io/html/) 定义

### 2、加载次级的资源

网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主线程在构建 DOM 的过程中会逐一请求它们，为了加速，preload scanner 会同时运行，如果在 html 中存在 img link 等标签，preload scanner 会把这些请求传递给 Browser process 中的 Network thread 进行相关资源的下载。

### 3、 JS 的下载与执行

HTML 的解析是流式的，不过当遇到 `<script>` 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 HTML 的原因在于 JS 可能会改变 DOM 的结构（使用诸如`document.write()`等 API）。

不过开发者其实也有多种方式来告知浏览器如何应对某个资源，比如说如果在 `<script>` 标签上添加了 `async` 或 `defer` 等属性，浏览器会异步的加载和执行 JS 代码，而不会阻塞渲染。

### 4、样式计算

仅仅渲染 DOM 还不足以知道页面的具体样式，渲染进程主线程还会基于 CSS 选择器解析 CSS 获取每一个节点最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式。

### 5、进行布局，构建布局树

想要渲染一个完整的页面，除了知道每个节点的具体样式，还需要知道每一个节点在页面上的位置。布局其实就是找到所有元素的几何关系的过程。具体过程如下：

通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树（layout tree）。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了`display: none;`，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。

### 6、分层，构建图层树

因为页面中有很多复杂的效果，如一些复杂的 3D 变换，页面滚动，或者使用 z-index 做 Z 轴排序等，为了更加方便的实现这些效果，主线程会遍历布局树来创建图层树（layer tree），例如添加了 `will-change` CSS 属性的元素，会被看做单独的一层。但是并不能无限制的给每一个元素都添加上`will-change`，因为组合过多的层会比在每一帧都栅格化页面中的某些小部分更慢。为了更合理的使用层，可参考[有限使用合成来控制层的数量](https://web.dev/stick-to-compositor-only-properties-and-manage-layer-count/)

- 拥有层叠上下文属性的元素会被提升为单独的一层：有明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等
- 需要裁剪（clip）的地方也会创建为图层

### 7、绘制元素

即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。

### 7、合成和显示

一旦图层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程会栅格化每一层。有的层可以达到整个页面的大小，因此，合成器线程将它们分成多个图块，并将每个图块发送到栅格线程，栅格线程会栅格化每一个图块并存储在 GPU 显存中。

一旦图块被光栅化，合成器线程会生成一个绘制图块的命令——“DrawQuad”，然后将该命令通过 IPC 消息传递给浏览器进程，浏览器进程里面有一个叫 viz 的组件，用来接收合成器线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

合成器线程的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。

## 推荐阅读

- [浏览器工作原理-渲染](https://www.gitsu.cn/detail?id=86)

---

- [CSS/JS 阻塞 DOM 解析和渲染](https://harttle.land/2016/11/26/static-dom-render-blocking.html)
- [异步渲染的下载和阻塞行为](https://harttle.land/2016/11/26/dynamic-dom-render-blocking.html)
- [浏览器的 16ms 渲染帧](https://harttle.land/2017/08/15/browser-render-frame.html)
- [关于每秒 60 帧](https://coffeeandtea.github.io/2020/11/10/%E5%85%B3%E4%BA%8E%E6%AF%8F%E7%A7%9260%E5%B8%A7/)
- [像素的一生](https://www.gitsu.cn/article95)
