(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{524:function(r,t,e){"use strict";e.r(t);var a=e(45),_=Object(a.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器的渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染"}},[r._v("#")]),r._v(" 浏览器的渲染")]),r._v(" "),e("p",[r._v("渲染进程（Renderer process）几乎负责浏览器 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。渲染进程中主要包含以下线程：")]),r._v(" "),e("ul",[e("li",[r._v("Main thread 一个主线程")]),r._v(" "),e("li",[r._v("Worker thread 多个工作线程")]),r._v(" "),e("li",[r._v("Compositor thread 一个合成器线程")]),r._v(" "),e("li",[r._v("Raster thread 多个光栅化线程")])]),r._v(" "),e("h2",{attrs:{id:"渲染流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染流程"}},[r._v("#")]),r._v(" 渲染流程")]),r._v(" "),e("h3",{attrs:{id:"_1、构建-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、构建-dom"}},[r._v("#")]),r._v(" 1、构建 DOM")]),r._v(" "),e("p",[r._v("当渲染进程接收到浏览器进程发起的“提交文档”消息，开始接收 HTML 数据时，主线程会解析文本字符串为 DOM。")]),r._v(" "),e("p",[r._v("渲染 HTML 为 DOM 的方法由 "),e("a",{attrs:{href:"https://whatwg-cn.github.io/html/",target:"_blank",rel:"noopener noreferrer"}},[r._v("HTML Standard"),e("OutboundLink")],1),r._v(" 定义")]),r._v(" "),e("h3",{attrs:{id:"_2、加载次级的资源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、加载次级的资源"}},[r._v("#")]),r._v(" 2、加载次级的资源")]),r._v(" "),e("p",[r._v("网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主线程在构建 DOM 的过程中会逐一请求它们，为了加速，preload scanner 会同时运行，如果在 html 中存在 img link 等标签，preload scanner 会把这些请求传递给 Browser process 中的 Network thread 进行相关资源的下载。")]),r._v(" "),e("h3",{attrs:{id:"_3、-js-的下载与执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、-js-的下载与执行"}},[r._v("#")]),r._v(" 3、 JS 的下载与执行")]),r._v(" "),e("p",[r._v("HTML 的解析是流式的，不过当遇到 "),e("code",[r._v("<script>")]),r._v(" 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 HTML 的原因在于 JS 可能会改变 DOM 的结构（使用诸如"),e("code",[r._v("document.write()")]),r._v("等 API）。")]),r._v(" "),e("p",[r._v("不过开发者其实也有多种方式来告知浏览器如何应对某个资源，比如说如果在 "),e("code",[r._v("<script>")]),r._v(" 标签上添加了 "),e("code",[r._v("async")]),r._v(" 或 "),e("code",[r._v("defer")]),r._v(" 等属性，浏览器会异步的加载和执行 JS 代码，而不会阻塞渲染。")]),r._v(" "),e("h3",{attrs:{id:"_4、样式计算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、样式计算"}},[r._v("#")]),r._v(" 4、样式计算")]),r._v(" "),e("p",[r._v("仅仅渲染 DOM 还不足以知道页面的具体样式，渲染进程主线程还会基于 CSS 选择器解析 CSS 获取每一个节点最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式。")]),r._v(" "),e("h3",{attrs:{id:"_5、进行布局-构建布局树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、进行布局-构建布局树"}},[r._v("#")]),r._v(" 5、进行布局，构建布局树")]),r._v(" "),e("p",[r._v("想要渲染一个完整的页面，除了知道每个节点的具体样式，还需要知道每一个节点在页面上的位置。布局其实就是找到所有元素的几何关系的过程。具体过程如下：")]),r._v(" "),e("p",[r._v("通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树（layout tree）。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了"),e("code",[r._v("display: none;")]),r._v("，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。")]),r._v(" "),e("h3",{attrs:{id:"_6、分层-构建图层树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、分层-构建图层树"}},[r._v("#")]),r._v(" 6、分层，构建图层树")]),r._v(" "),e("p",[r._v("因为页面中有很多复杂的效果，如一些复杂的 3D 变换，页面滚动，或者使用 z-index 做 Z 轴排序等，为了更加方便的实现这些效果，主线程会遍历布局树来创建图层树（layer tree），例如添加了 "),e("code",[r._v("will-change")]),r._v(" CSS 属性的元素，会被看做单独的一层。但是并不能无限制的给每一个元素都添加上"),e("code",[r._v("will-change")]),r._v("，因为组合过多的层会比在每一帧都栅格化页面中的某些小部分更慢。为了更合理的使用层，可参考"),e("a",{attrs:{href:"https://web.dev/stick-to-compositor-only-properties-and-manage-layer-count/",target:"_blank",rel:"noopener noreferrer"}},[r._v("有限使用合成来控制层的数量"),e("OutboundLink")],1)]),r._v(" "),e("ul",[e("li",[r._v("拥有层叠上下文属性的元素会被提升为单独的一层：有明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等")]),r._v(" "),e("li",[r._v("需要裁剪（clip）的地方也会创建为图层")])]),r._v(" "),e("h3",{attrs:{id:"_7、绘制元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、绘制元素"}},[r._v("#")]),r._v(" 7、绘制元素")]),r._v(" "),e("p",[r._v("即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。")]),r._v(" "),e("h3",{attrs:{id:"_7、合成和显示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、合成和显示"}},[r._v("#")]),r._v(" 7、合成和显示")]),r._v(" "),e("p",[r._v("一旦图层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程会栅格化每一层。有的层可以达到整个页面的大小，因此，合成器线程将它们分成多个图块，并将每个图块发送到栅格线程，栅格线程会栅格化每一个图块并存储在 GPU 显存中。")]),r._v(" "),e("p",[r._v("一旦图块被光栅化，合成器线程会生成一个绘制图块的命令——“DrawQuad”，然后将该命令通过 IPC 消息传递给浏览器进程，浏览器进程里面有一个叫 viz 的组件，用来接收合成器线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。")]),r._v(" "),e("p",[r._v("合成器线程的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。")]),r._v(" "),e("h2",{attrs:{id:"推荐阅读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#推荐阅读"}},[r._v("#")]),r._v(" 推荐阅读")]),r._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://www.gitsu.cn/detail?id=86",target:"_blank",rel:"noopener noreferrer"}},[r._v("浏览器工作原理-渲染"),e("OutboundLink")],1)])]),r._v(" "),e("hr"),r._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://harttle.land/2016/11/26/static-dom-render-blocking.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("CSS/JS 阻塞 DOM 解析和渲染"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://harttle.land/2016/11/26/dynamic-dom-render-blocking.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("异步渲染的下载和阻塞行为"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://harttle.land/2017/08/15/browser-render-frame.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("浏览器的 16ms 渲染帧"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://coffeeandtea.github.io/2020/11/10/%E5%85%B3%E4%BA%8E%E6%AF%8F%E7%A7%9260%E5%B8%A7/",target:"_blank",rel:"noopener noreferrer"}},[r._v("关于每秒 60 帧"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://www.gitsu.cn/article95",target:"_blank",rel:"noopener noreferrer"}},[r._v("像素的一生"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=_.exports}}]);