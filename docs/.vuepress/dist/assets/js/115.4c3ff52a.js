(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{562:function(t,n,e){"use strict";e.r(n);var a=e(45),r=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"typescript-基本语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typescript-基本语法"}},[t._v("#")]),t._v(" TypeScript 基本语法")]),t._v(" "),e("h2",{attrs:{id:"名词解释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#名词解释"}},[t._v("#")]),t._v(" 名词解释")]),t._v(" "),e("h3",{attrs:{id:"类型注解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型注解"}},[t._v("#")]),t._v(" 类型注解")]),t._v(" "),e("p",[t._v("作用：相当于强类型语言中的类型声明")]),t._v(" "),e("p",[t._v("语法：(变量/函数): type")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" str"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'abc'")]),t._v("\n")])])]),e("h3",{attrs:{id:"联合类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#联合类型"}},[t._v("#")]),t._v(" 联合类型")]),t._v(" "),e("p",[t._v("联合类型（Union Types）表示取值可以为多种类型中的一种。")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" count"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n")])])]),e("h3",{attrs:{id:"枚举"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#枚举"}},[t._v("#")]),t._v(" 枚举")]),t._v(" "),e("p",[t._v("一组有名字的常量集合，可以类比手机里的通讯录。、")]),t._v(" "),e("h3",{attrs:{id:"泛型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),e("p",[t._v("不预先确定的数据类型，具体的类型在使用的时候才能确定。泛型变量可以类比函数参数，是代表类型的参数。")]),t._v(" "),e("h2",{attrs:{id:"语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),e("h3",{attrs:{id:"es6-的数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6-的数据类型"}},[t._v("#")]),t._v(" ES6 的数据类型")]),t._v(" "),e("ul",[e("li",[t._v("Boolean")]),t._v(" "),e("li",[t._v("Number")]),t._v(" "),e("li",[t._v("String")]),t._v(" "),e("li",[t._v("undefined")]),t._v(" "),e("li",[t._v("null")]),t._v(" "),e("li",[t._v("Symbol")]),t._v(" "),e("li",[t._v("Array")]),t._v(" "),e("li",[t._v("Function")]),t._v(" "),e("li",[t._v("Object")])]),t._v(" "),e("h3",{attrs:{id:"es6-的数据类型-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6-的数据类型-2"}},[t._v("#")]),t._v(" ES6 的数据类型")]),t._v(" "),e("ul",[e("li",[t._v("Boolean")]),t._v(" "),e("li",[t._v("Number")]),t._v(" "),e("li",[t._v("String")]),t._v(" "),e("li",[t._v("undefined")]),t._v(" "),e("li",[t._v("null")]),t._v(" "),e("li",[t._v("Symbol")]),t._v(" "),e("li",[t._v("Array")]),t._v(" "),e("li",[t._v("Function")]),t._v(" "),e("li",[t._v("Object")]),t._v(" "),e("li",[e("strong",[t._v("void")])]),t._v(" "),e("li",[e("strong",[t._v("any")])]),t._v(" "),e("li",[e("strong",[t._v("never")])]),t._v(" "),e("li",[e("strong",[t._v("元组")])]),t._v(" "),e("li",[e("strong",[t._v("枚举")])]),t._v(" "),e("li",[e("strong",[t._v("高级类型")])])]),t._v(" "),e("h3",{attrs:{id:"类型注解-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型注解-2"}},[t._v("#")]),t._v(" 类型注解")]),t._v(" "),e("p",[t._v("作用： 相当于强类型语言中的类型声明")]),t._v(" "),e("p",[t._v("语法：(变量/函数):type")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 原始值\nconst isDone: boolean = false;\nconst amount: number = 6;\nconst address: string = 'beijing';\nconst greeting: string = `Hello World`;\n\n// 数组\nconst list: number[] = [1, 2, 3];\nconst list: Array<number> = [1, 2, 3];\n\n// 元组\nconst name: [string, string] = ['Sean', 'Sun'];\n\n// 枚举\nenum Color {\n    Red,\n    Green,\n    Blue\n};\nconst c: Color = Color.Green;\n\n// 任意值：可以调用任意方法\nlet anyTypes: any = 4;\nanyTypes = 'any';\nanyTypes = false;\n\n// 空值\nfunction doSomething (): void {\n    return undefined;\n}\n\n// 类型断言\nlet someValue: any = \"this is a string\";\nlet strLength: number = (someValue as string).length;\n")])])]),e("h3",{attrs:{id:"typescript-中的-interface-可以看做是一个集合-这个集合是对对象、类等内部结构的约定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typescript-中的-interface-可以看做是一个集合-这个集合是对对象、类等内部结构的约定"}},[t._v("#")]),t._v(" TypeScript 中的 Interface 可以看做是一个集合，这个集合是对对象、类等内部结构的约定")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 定义接口 Coords\n// 该接口包含 number 类型的 x，string 类型的 y\n// 其中 y 是可选类型，即是否包含该属性无所谓\ninterface Coords {\n\tx: number;\n\ty?: string;\n};\n\n// 定义函数 where\n// 该函数接受一个 Coords 类型的参数 l\nfunction where (l: Coords) {\n\t// doSomething\n}\n\nconst a = { x: 100 };\nconst b = { x: 100, y1: 'abc' };\n// a 拥有 number 类型的 x，可以传递给 where\nwhere(a);\n// b 拥有 number 类型的 x 和 string 类型的 y1，可以传递给 where\nwhere(b);\n\n// 下面这种调用方式将会报错，虽然它和 where(b) 看起来是一致的\n// 区别在于这里传递的是一个对象字面量\n// 对象字面量会被特殊对待并经过额外的属性检查\n// 如果对象字面量中存在目标类型中未声明的属性，则抛出错误\nwhere({ x: 100, y1: 'abc' });\n\n// 最好的解决方式是为接口添加索引签名\n// 添加如下所示的索引签名后，对象字面量可以有任意数量的属性\n// 只要属性不是 x 和 y，其他属性可以是 any 类型\ninterface Coords {\n\tx: number;\n\ty?: string;\n    [propName: string]: any\n};\n")])])]),e("h3",{attrs:{id:"接口还常用于约束函数的行为"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口还常用于约束函数的行为"}},[t._v("#")]),t._v(" 接口还常用于约束函数的行为")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// CheckType 包含一个调用签名\n// 该调用签名声明了 getType 函数需要接收一个 any 类型的参数，并最终返回一个 string 类型的结果\ninterface CheckType {\n    (data: any): string;\n};\nconst getType: CheckType = (data: any) : string => {\n    return Object.prototype.toString.call(data);\n}\ngetType('abc');\n// => '[object String]'\n")])])]),e("h3",{attrs:{id:"interface-也可以用于约束类的行为"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#interface-也可以用于约束类的行为"}},[t._v("#")]),t._v(" Interface 也可以用于约束类的行为")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('interface ClockConstructor {\n    new (hour: number, minute: number): ClockInterface;\n}\ninterface ClockInterface {\n    tick();\n}\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n    return new ctor(hour, minute);\n}\nclass DigitalClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log("beep beep");\n    }\n}\nclass AnalogClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log("tick tock");\n    }\n}\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n')])])]),e("h3",{attrs:{id:"除了-es6-增加的-class-用法-typescript-还增加了-c-、java-中常见的-public-protected-private-限定符-限定变量或函数的使用范围。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#除了-es6-增加的-class-用法-typescript-还增加了-c-、java-中常见的-public-protected-private-限定符-限定变量或函数的使用范围。"}},[t._v("#")]),t._v(" 除了 ES6 增加的 Class 用法，TypeScript 还增加了 C++、Java 中常见的 public / protected / private 限定符，限定变量或函数的使用范围。")]),t._v(" "),e("p",[t._v("TypeScript 使用的是结构性类型系统，只要两种类型的成员类型相同，则认为这两种类型是兼容和一致的，但比较包含 private 和 protected 成员的类型时，只有他们是来自同一处的统一类型成员时才会被认为是兼容的")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class Animal {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\nclass Rhino extends Animal {\n    constructor() { super("Rhino"); }\n}\nclass Employee {\n    private name: string;\n    constructor(theName: string) { this.name = theName; }\n}\n\nlet animal = new Animal("Goat");\nlet rhino = new Rhino();\nlet employee = new Employee("Bob");\n\nanimal = rhino;\n// Error: Animal and Employee are not compatible\nanimal = employee;\n')])])]),e("h3",{attrs:{id:"function"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#function"}},[t._v("#")]),t._v(" function")])])}),[],!1,null,null,null);n.default=r.exports}}]);