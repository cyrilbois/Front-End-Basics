(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{517:function(e,r,s){"use strict";s.r(r);var t=s(45),v=Object(t.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"css-选择器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-选择器"}},[e._v("#")]),e._v(" CSS 选择器")]),e._v(" "),s("p",[e._v("// TODO")]),e._v(" "),s("h2",{attrs:{id:"css-选择器有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-选择器有哪些"}},[e._v("#")]),e._v(" CSS 选择器有哪些?")]),e._v(" "),s("h2",{attrs:{id:"什么是-css-选择器权重以及它如何工作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-css-选择器权重以及它如何工作"}},[e._v("#")]),e._v(" 什么是 CSS 选择器权重以及它如何工作？")]),e._v(" "),s("h2",{attrs:{id:"为什么浏览器从右到左匹配-css-选择器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么浏览器从右到左匹配-css-选择器"}},[e._v("#")]),e._v(" 为什么浏览器从右到左匹配 CSS 选择器？")]),e._v(" "),s("p",[e._v("首先我们要看一下选择器的"),s("code",[e._v("解析")]),e._v("是在何时进行的。")]),e._v(" "),s("p",[e._v("浏览器渲染的过程大概如下：")]),e._v(" "),s("p",[e._v("HTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（Webkit 中称为 "),s("code",[e._v("renderers")]),e._v("，Firefox 中成为 "),s("code",[e._v("frames")]),e._v("）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的"),s("strong",[e._v("行")]),e._v("会成为 Render Tree 中不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none;元素。")]),e._v(" "),s("p",[e._v("在建立 Render Tree 时（Webkit 中的 "),s("code",[e._v("Attachment")]),e._v(" 过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器"),s("code",[e._v("解析")]),e._v("实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。")]),e._v(" "),s("p",[e._v("因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断"),s("strong",[e._v("这个 selector 不匹配当前元素")]),e._v("就是及其重要的。")]),e._v(" "),s("p",[e._v("如果正向解析，例如 "),s("code",[e._v("div div p em")]),e._v("，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层的那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。")]),e._v(" "),s("p",[e._v("逆向匹配则不同，如果当前的 DOM 元素是 div，而不是 selector 最后的 em，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。")]),e._v(" "),s("p",[e._v("但因为匹配的情况远远低于不匹配的情况，所以逆向匹配带来的优势是巨大的。同时我们也能够看出，在选择器结尾加上 "),s("code",[e._v("*")]),e._v(" 就大大降低了这种优势，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。")]),e._v(" "),s("h2",{attrs:{id:"什么是-切片-sectioning-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-切片-sectioning-算法"}},[e._v("#")]),e._v(" 什么是 切片（sectioning） 算法？")])])}),[],!1,null,null,null);r.default=v.exports}}]);