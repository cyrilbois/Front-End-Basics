# Set 、 Map 和垃圾回收

## Set

Set 类型是一种**有序列表**，其中含有一些**相互独立**的**非重复值**，通过 Set 集合可以快速访问其中的数据，更有效地追踪各种离散值。

在 Set 集合中，不会对所存值进行强制类型转换，数字 5 和字符串 "5" 可以作为两个独立元素存在（引擎内部使用 `Object.is()` 方法检测两个值是否一致，唯一的例外是，Set 集合中的 +0 和 -0 被认为是相等的），当然，如果向 Set 集合中添加多个对象，则它们之间彼此保持独立。

### Set 的一些特性

- Set 的方法和属性包括：`add()` `delete()` `clear()` `has()` `keys()` `values()` `entries()` `forEach()` `size`属性，`keys()` `values()` `entries()` 返回的都是一个迭代器对象
- 如果多次调用 `add()` 方法并传入相同的值作为参数，那么后续的调用实际上会被忽略。
- Set 构造函数可以接受所有可迭代对象作为参数，数组、Set 集合、Map 集合，DOM 中的 NodeList 对象、String 对象，函数的 arguments 属性，都是可迭代的，因而都可以作为 Set 构造函数的参数使用；构造函数通过迭代器从参数中提取值。
- 通过 `has()` 方法可以检测 Set 集合中是否存在某个值。之前在对象中都是读取对象的值来判断属性是否存在，但是在 JavaScript 中有一个 `in` 运算符，其不需要读取对象的值就可以判断属性在对象中是否存在，如果存在就返回 true。但是 `in` 运算符也会检索对象的原型，只有当对象原型为 `null` 时使用这个方法才比较稳妥。即便是这样，也建议使用 `in` 运算符，不过实际开发中许多开发者仍然使用访问属性的方法进行判断，并没有使用 in 运算符。
- Set 集合的 `forEach()` 方法比较特别，**回调函数的前两个参数的值竟然是一样的**。尽管这看起来像是一个错误，不过也解释的通。数组和 Map 集合的 `forEach()` 的回调函数都接受 3 个参数，**前两个分别是值和键名（对于数组来说就是数值型索引值）**，然而 Set 集合没有键名，ECMAScript 6 标准制定委员会本可以规定 Set 集合的 `forEach()` 的回调函数只接受两个参数，但这可能导致几个方法之间分歧过大，于是他们最终决定所有函数都接受 3 个参数：Set 集合中的每个元素也按照键名和值的形式存储，从而才能保证在所有 `forEach()` 方法的回调函数中前两个参数值具有相同含义。
- 尽管 Set 集合更适合用来跟踪多个值，而且又可以通过 forEach() 方法操作集合中的每一个元素，但是不能像访问数组元素那样直接通过索引访问集合中的元素。如有需要，最好先将 Set 集合转换成一个数组，方法可以用展开运算符 `...` 或者 `Array.from()`

> 展开运算符（展开语法）`...` ，可以在函数调用/数组构造时，将数组表达式或者 string 在语法层面展开（其他的可迭代对象也可以），还可以再构造字面量对象时，将对象表达式按 key-value 的方式展开。

### Weak Set

- Set 类型可以被看作是一个强引用的 Set 集合，Weak Set 集合是弱引用的 Set 集合。Weak Set 集合**只存储对象的弱引用，并且不可以存储原始值**；集合中的弱引用如果是对象唯一的引用，则会被垃圾回收并释放相应内存。
- Weak Set 集合支持 3 个方法：`add()`、 `has()`、 `delete()`
- Weak Set 不接受任何原始值，如果 WeakSet 构造函数传入的数组中包含其他非对象值，程序会抛出错误，如果在 WeakSet 实例中，向 `add()` 方法传入非对象参数会导致程序报错，而向 `has()` 和 `delete()` 方法传入非对象参数则会返回 false
- Weak Set 集合不可迭代，所以不能被用于 for-of 循环，也不支持 `forEach()` 方法
- Weak Set 集合不暴露任何迭代器（例如 `keys()` 和 `values()` 方法），所以无法通过程序本身来检测其中的内容
- Weak Set 集合不支持 size 属性
- Weak Set 集合的功能看似受限，其实这是为了让它能够正确地处理内存中的数据。总之，如果只需要跟踪对象引用，更应该使用 Weak Set 集合而不是普通的 Set 集合

### 实用

Set 集合中都是相互对立的非重复值，所以可以用于数组去重

```js
function eliminateDuplicates(items) {
  return [...new Set(items)]
}
```

## Map

ECMAScript 6 中的 Map 类型是一种存储着许多**键值对**的**有序列表**，其中的键名和对应的值**支持所有的数据类型**。键名的等价性判断是通过调用 Object.is() 方法实现的，所以数字 `5` 与字符串 `"5"` 会被判定为两种类型，可以分别作为独立的两个键。

### Map 的一些特性

- Map 的方法和属性：`set()` `get()` `delete()` `clear()` `has()` `keys()` `values()` `entries()` `forEach()` `size`属性
- 初始化 Map 构造函数时，需要用到二维数组。数组包裹数组的模式看起来可能有点奇怪，但由于 Map 集合可以接受任意数据类型的键名，为了确保他们在被存储到 Map 集合之前不会被强制转换为其他数据类型，因而只能将它们放在数组中，因为这是唯一一种可以准确地呈现键名类型的方式。

### Weak Map

- ECMAScript 6 中的 Weak Map 类型是一种存储着许多键值对的无序列表，列表的键名必须是非 `null` 类型的对象，键名对应的值则可以是任意类型
- Weak Map 是弱引用 Map 集合，用于存储对象的弱引用，集合中保存这些对象的弱引用，如果在弱引用之外不存在其他的强引用，引擎的垃圾回收机制会自动回收这个对象，同时也会移除 Weak Map 集合中的键值对，但是只有集合的键名遵从这个规则，键名对应的值如果是一个对象，则保存的是对象的强引用，不会触发垃圾回收机制。
- Weak Map 集合中的键名必须是一个对象，如果使用非对象键名会报错
- Weak Map 集合只支持 4 个可以操作键值对的方法： `set()` `get()` `has()` `delete()`

## JavaScript 运行环境的栈和堆

### 栈内存（Stack memory）

> 栈（Stack）的特点是“LIFO，即后进先出（last in first out）”。数据存储时只能从顶部逐个存入，取出时也需要从顶部逐个取出。

栈内存之所以叫做栈内存，是因为栈内存使用了栈的结构，栈内存是一段连续的内存空间，得益于栈结构的简单直接，栈内存的访问和操作速度都非常快。

栈内存空间比较小（例如 V8 默认栈区的大小是 984K），主要用于存放函数调用信息和变量等数据，大量的内存分配操作会导致栈溢出（Stack overflow），例如函数递归没有终止条件等。

栈内存中储存的数据基本都是临时性的，数据会在使用完之后立即被回收（如函数内创建的局部变量在函数执行完毕后就会被回收），而且不需要程序进行操作，操作系统会自动回收。

> 补充栈内存大小：栈内存由操作系统直接管理，所以栈内存的大小也由操作系统决定。通常来说，每一个线程（Thread）都会有独立的栈内存空间，Windows 给每条线程分配的栈内存默认大小为 1MB

### 堆内存（Heap memory）

> 堆（Heap）的特点是“无序”的 `key-value`“键值对”存储方式，堆的存取方式跟顺序没有关系，不局限出入口。

堆内存虽然名字里有个“堆”字，但是它和数据结构中的堆关系不大，只是名字相近。

堆内存是一大片内存空间，堆内存中的内存分配是动态且不连续的，程序可以按需申请堆内存空间，但是访问速度要比栈内存慢不少。

堆内存里的数据可以长时间存在，无用的数据需要程序主动去回收，如果大量无用数据占用内存就会造成内存泄漏（Memory leak）。

> 补充堆内存大小：在 Node.js 中，堆内存默认上限在 64 位系统中约为 1.4GB，在 32 位系统中约为 0.7GB。而在 Chrome 浏览器中，每个标签页的内存上限为 4GB（64 位系统）和 1GB（32 位系统）。通常来说，一个进程（Process）只会有一个堆内存，同一进程下的多个线程会共享同一个堆内存。

### 总结一下栈内存和堆内存的特点

- 栈内存适合存放生命周期短、占用空间小且固定的数据。而且无需手动管理，函数调用时创建，调用结束则消失
- 堆内存适合存放生命周期长、占用空间大或占用空间不固定的数据。

## JavaScript 变量存储机制

首先确定一点，“一个变量，如果是原始类型，数据本身是存在栈内，如果是对象，数据本身会存储在堆中，在栈中存的只是一个堆内地址的引用” 这样的说法是有问题的。

JavaScript 中变量存储在内存中的位置取决于 JavaScript 引擎的实现，早期的 JavaScript 编译器甚至把所有的变量都存在一个名为闭包的对象中，因为 JavaScript 是一门以函数为基础的语言，其中的函数变化无穷（闭包），因此使用栈内存并不能解决语言方面的问题，而堆内存则方便存储各种类型得到的变量。

现在的 JavaScript 引擎通常做了很多优化，变量的存储位置也是根据具体情况而定的。比如，一个 string 类型的变量可能有几十 M，栈内存肯定是放不下的，再比如闭包中外层函数的局部变量有时并不会随外层函数的调用结束而清空。

### 函数调用栈

当函数被调用时，会将函数推入栈内存中，生成一个栈帧（Stack frame），栈帧可以理解为由 参数、函数的返回地址和局部变量组成的一个块；当函数调用另外一个函数时，又会将另一个函数也推入栈内存中，周而复始，直到最后一个函数返回，便从栈顶开始讲栈内存中的元素逐个弹出，直到栈内存中不再有元素时则此次调用结束。

在同一线程下（JavaScript 是单线程的），所有被执行的函数以及函数的参数和局部变量都会被推入到同一个栈内存中，这也就是大量递归会导致栈溢出（Stack overflow）的原因。

### 普通的 JavaScript 引擎的变量存储

在 JavaScript 程序运行时，非全局作用域中产生的局部变量存储在栈内存中，不过，只有原始类型的变量是真正地把值存储在栈内存中，而引用类型的变量只在栈内存中储存一个引用地址，这个引用指向堆内存里的真正的值。

## 垃圾回收

在计算机科学中，垃圾回收（Garbage Collection 简称 GC）是一种存储器管理机制，也就是清除内存中不再需要的数据，释放内存空间。

当某个程序（执行环境）占用的一部分内存空间不再被这个程序（执行环境）访问时，这个程序（执行环境）会借助垃圾回收算法向操作系统归还这部分内存空间（垃圾回收器做的事情）。垃圾回收可以是手动触发，也可以是自动的。

JavaScript 是一门具有自动垃圾回收机制的编程语言，由执行环境（例如 V8 引擎）负责在代码执行时管理内存。JavaScript 的自动垃圾回收机制很简单：**找出那些不再继续使用的变量，然后释放其所占用的内存**，垃圾回收器会按照固定的时间间隔周期性地执行这一操作。在 JavaScript 中，原始类型的数据被分配到栈空间中，引用类型的数据会被分配到堆空间中。局部变量只有在函数执行的过程中存在，在这个过程中，一般情况下会为局部变量在栈内存上分配空间，然后在函数中使用这些变量，直至函数执行结束。

> **垃圾回收**是一种存储器管理机制，每个程序都可以实现垃圾回收这个机制，不同的程序使用不同的**垃圾回收算法**构成了不同的**垃圾回收器**，触发垃圾回收器进行垃圾回收可以分为手动和自动，JavaScript 的**自动垃圾回收机制**就是让垃圾回收器按照固定的时间间隔周期性的找出那些不再继续使用的变量，然后释放其所占用的内存。

![](./images/gc.jpg)

### 垃圾回收原理

垃圾回收器必须追踪每个变量的使用情况，为那些不再使用的变量打上标记，用于将来能及时回收其占用的内存，用于标识无用变量的策略主要有引用计数法和标记清除法。

## 问题

### 为什么说 JavaScript 是一门具有自动垃圾回收机制的编程语言？

这是站在开发者的角度来看的，在 C 和 C++ 等语言中，开发人员需要直接控制内存的申请和回收，但是在 Java、C#、JavaScript 语言中，变量的内存空间的申请和释放都由程序（例如 V8 引擎）自己处理，开发人员不需要特别关心。

### JavaScript 哪些数据类型会保存在栈中，哪些数据类型会保存在堆中
